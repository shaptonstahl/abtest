{
    "contents" : "library(shiny)\n\nDifferenceOfMedians <- function(x, y, frac.dropped=.2, n.iter=1000, silent=FALSE) {\n  #' Given two vectors return the distribution of difference of means\n  #' calculated using bootstrapping\n  \n  OneDraw <- function() {\n    boot.x <- sample(x, round((1-frac.dropped)*length(x)), replace=TRUE)\n    boot.y <- sample(y, round((1-frac.dropped)*length(y)), replace=TRUE)\n    return(median(boot.x) - median(boot.y))\n  }\n  \n  draws <- numeric(0)\n    for(i in 1:n.iter) {\n      draws <- c(draws, OneDraw())\n    }\n  \n  if(!silent) {\n    cat(\"Difference of Medians test via the bootstrap\\n\")\n    cat(\"Median of x:\", median(x), \"\\n\")\n    cat(\"Median of y:\", median(y), \"\\n\")\n    cat(\"Probability that median(x) > median(y):\", round(mean(draws > 0), 2), \"\\n\")\n  }\n  return(list(prob.x.greater=mean(draws > 0),\n              draws.x.greater=draws))\n}\n\nProbs <- function(draws, mme) {\n  return(c(negative=mean(draws < -mme),\n           near.zero=mean(draws < mme & draws > -mme),\n           positive=mean(draws > mme)))\n}\n\nSampleSizeNeeded <- function(draws, n.current, mme, certainty.fraction) {\n  if(median(draws) < -mme) {\n    out <- (quantile(draws, certainty.fraction) - median(draws)) / (-mme - median(draws)) * n.current\n  } else if(median(draws) > mme) {\n    out <- (median(draws) - quantile(draws, 1 - certainty.fraction)) / (median(draws) - mme) * n.current\n  } else {\n    f <- function(v) mean(draws < v & draws > -v) - certainty.fraction\n    ur <- uniroot(f, lower=0, upper=max(abs(draws))+1)\n    out <- (ur$root - median(draws)) / (mme - median(draws)) * n.current\n  }\n  out <- round(out)\n  names(out) <- NULL\n  return(out)\n}\n\nObservationsNeededMessage <- function(current.obs, needed.obs, desired.certainty) {\n  if(current.obs >= needed.obs) {\n    return(paste(\"You (should) already have already exceeded \", desired.certainty, \"% certainty. If not, you're very close.\", sep=\"\"))\n  } else {\n    return(paste(\"If the mean so far is correct, we estimate that you will need a total of \", needed.obs,\n                 \" (\", needed.obs-current.obs, \" additional) observations to reach \", \n                 desired.certainty, \"% certainty.\",\n                 sep=\"\"))\n  }\n}\n\nPlotCohortEffect <- function(draws, cohort1, cohort2, mme, certainty.fraction, n.x, n.y) {\n  if(mean(draws) > 0) {\n    winning.cohort <- cohort1\n    losing.cohort <- cohort2\n    legend.offset <- .1  # fraction of x range legend is from the left\n  } else {\n    winning.cohort <- cohort2\n    losing.cohort <- cohort1\n    legend.offset <- .7\n  }\n  probs <- Probs(draws, mme)\n  \n  if(max(probs) < certainty.fraction) {\n    title <- paste(winning.cohort, \" is ahead of \", losing.cohort, \", but it is not yet conclusive\", sep=\"\")\n  } else {\n    if(probs['positive'] > certainty.fraction | probs['negative'] > certainty.fraction) {\n      title <- paste(winning.cohort, \" beat \", losing.cohort, sep=\"\")\n    } else {\n      title <- \"It's a tie\"\n    }\n  }\n  \n  xlim <- c(min(c(-mme, draws)), max(c(mme, draws)))\n  \n  xlab <- paste(\"Sample size = \", n.x, \" + \", n.y, \n                \".  The difference between cohorts is about \", round(mean(abs(draws))), \" seconds\", sep=\"\")\n  \n  h <- hist(draws, 50, xlim=xlim,\n            main=title, \n            xlab=xlab,\n            axes=FALSE,\n            ylab='')\n  axis(1)\n  abline(v=c(mme, -mme), lty=2, lwd=2)\n  legend(x=legend.offset * (xlim[2] - xlim[1]) + xlim[1],\n         y=.8 * max(h$counts),\n         legend=c(paste(cohort1, \" wins: \", round(probs['positive']*100), \"%\", sep=\"\"),\n                  paste(\"It's a tie: \", round(probs['near.zero']*100), \"%\", sep=\"\"),\n                  paste(cohort2, \" wins: \", round(probs['negative']*100), \"%\", sep=\"\")),\n         title=\"Probabilities\")\n}\n\nReadX <- function(cohort) {\n  #' This function is written for the demo data.\n  #' You can write this to hit a SQL database, read the output of a PHP file, etc.\n  x <- read.delim(paste('data_', cohort, '.tsv', sep=''))[,1]\n  return(x)\n}\n\n# Define server logic required to draw a histogram\nshinyServer(function(input, output, session) {\n  \n  # Read the data\n  x1 <- reactive({\n    ReadX(cohort=input$cohort1)\n  })\n  x2 <- reactive({\n    ReadX(cohort=input$cohort2)\n  })\n  \n  # Perform bootstrap calculation\n  bootstrap.result <- reactive({\n    DifferenceOfMedians(x1(), x2(), silent=TRUE)\n  })\n  \n  output$obs.needed <- renderText({\n    needed.obs <- SampleSizeNeeded(bootstrap.result()$draws.x.greater,\n                                   n.current=length(x1())+length(x2()),\n                                   mme=input$min.meaningful.effect, \n                                   certainty.fraction=input$confidence.percent/100)\n    ObservationsNeededMessage(current.obs=length(x1()) + length(x2()), \n                              needed.obs=needed.obs,\n                              desired.certainty=input$confidence.percent)\n  })\n\n  output$distPlot <- renderPlot({\n    PlotCohortEffect(draws=bootstrap.result()$draws.x.greater, \n                     cohort1=input$cohort1, \n                     cohort2=input$cohort2, \n                     mme=input$min.meaningful.effect, \n                     certainty.fraction=input$confidence.percent/100,\n                     n.x=length(x1()), \n                     n.y=length(x2()))\n  })\n  \n})\n",
    "created" : 1425748871060.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2857212255",
    "id" : "E3A1D298",
    "lastKnownWriteTime" : 1425750506,
    "path" : "~/GitHub/abtest/ab-boot-demo/server.R",
    "project_path" : "ab-boot-demo/server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}